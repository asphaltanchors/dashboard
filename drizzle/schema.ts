import { pgTable, pgSchema, varchar, text, boolean, numeric, timestamp, doublePrecision, bigint, date, json, integer } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const analyticsMart = pgSchema("analytics_mart");


export const fctProductsInAnalyticsMart = analyticsMart.table("fct_products", {
	quickBooksInternalId: varchar("quick_books_internal_id"),
	itemName: varchar("item_name"),
	salesDescription: varchar("sales_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	purchaseDescription: varchar("purchase_description"),
	salesPrice: numeric("sales_price"),
	purchaseCost: numeric("purchase_cost"),
	marginPercentage: numeric("margin_percentage"),
	marginAmount: numeric("margin_amount"),
	manufacturerSPartNumber: varchar("manufacturer_s_part_number"),
	unitOfMeasure: varchar("unit_of_measure"),
	loadDate: varchar("load_date"),
	snapshotDate: varchar("snapshot_date"),
});

export const bridgeCustomerCompanyInAnalyticsMart = analyticsMart.table("bridge_customer_company", {
	customerId: varchar("customer_id"),
	companyDomainKey: text("company_domain_key"),
	customerName: varchar("customer_name"),
	customerCompanyName: varchar("customer_company_name"),
	standardizedCustomerName: text("standardized_customer_name"),
	customerNameNormalizationType: text("customer_name_normalization_type"),
	mainEmail: varchar("main_email"),
	ccEmail: varchar("cc_email"),
	mainPhone: varchar("main_phone"),
	billingAddressLine1: varchar("billing_address_line_1"),
	billingAddressCity: varchar("billing_address_city"),
	billingAddressState: varchar("billing_address_state"),
	billingAddressPostalCode: varchar("billing_address_postal_code"),
	salesRep: varchar("sales_rep"),
	terms: varchar(),
	priceLevel: varchar("price_level"),
	currentBalance: numeric("current_balance", { precision: 38, scale:  9 }),
	customerStatus: boolean("customer_status"),
	customerCreatedDate: timestamp("customer_created_date", { mode: 'string' }),
	customerModifiedDate: timestamp("customer_modified_date", { mode: 'string' }),
	domainType: text("domain_type"),
	customerTotalRevenue: doublePrecision("customer_total_revenue"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	customerTotalOrders: bigint("customer_total_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	customerTotalLineItems: bigint("customer_total_line_items", { mode: "number" }),
	customerFirstOrderDate: date("customer_first_order_date"),
	customerLatestOrderDate: date("customer_latest_order_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	customerOrderDays: bigint("customer_order_days", { mode: "number" }),
	customerValueTier: text("customer_value_tier"),
	customerActivityStatus: text("customer_activity_status"),
	ordersPerDay: numeric("orders_per_day"),
	isIndividualCustomer: boolean("is_individual_customer"),
	isMissingEmail: boolean("is_missing_email"),
	hasRevenue: boolean("has_revenue"),
	isActiveCustomer: boolean("is_active_customer"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctOrdersInAnalyticsMart = analyticsMart.table("fct_orders", {
	orderNumber: varchar("order_number"),
	sourceType: text("source_type"),
	orderDate: date("order_date"),
	customer: text(),
	paymentMethod: text("payment_method"),
	status: text(),
	dueDate: date("due_date"),
	primaryContactId: text("primary_contact_id"),
	primaryContactName: text("primary_contact_name"),
	primaryContactEmail: text("primary_contact_email"),
	primaryContactPhone: text("primary_contact_phone"),
	primaryContactRole: text("primary_contact_role"),
	isTaxExempt: boolean("is_tax_exempt"),
	isPaid: boolean("is_paid"),
	isBackdated: boolean("is_backdated"),
	billingAddress: text("billing_address"),
	billingAddressCity: text("billing_address_city"),
	billingAddressState: text("billing_address_state"),
	billingAddressPostalCode: text("billing_address_postal_code"),
	billingAddressCountry: text("billing_address_country"),
	shippingAddress: text("shipping_address"),
	shippingAddressCity: text("shipping_address_city"),
	shippingAddressState: text("shipping_address_state"),
	shippingAddressPostalCode: text("shipping_address_postal_code"),
	shippingAddressCountry: text("shipping_address_country"),
	primaryCountry: text("primary_country"),
	countryCategory: text("country_category"),
	region: text(),
	shippingMethod: text("shipping_method"),
	shipDate: date("ship_date"),
	memo: text(),
	messageToCustomer: text("message_to_customer"),
	class: text(),
	currency: text(),
	exchangeRate: text("exchange_rate"),
	terms: text(),
	salesRep: text("sales_rep"),
	salesChannel: text("sales_channel"),
	customerSegment: text("customer_segment"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	transactionId: bigint("transaction_id", { mode: "number" }),
	quickbooksInternalId: text("quickbooks_internal_id"),
	externalId: text("external_id"),
	createdDate: timestamp("created_date", { mode: 'string' }),
	modifiedDate: timestamp("modified_date", { mode: 'string' }),
	totalLineItemsAmount: numeric("total_line_items_amount"),
	totalTax: doublePrecision("total_tax"),
	totalAmount: numeric("total_amount"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	itemCount: bigint("item_count", { mode: "number" }),
	effectiveTaxRate: numeric("effective_tax_rate"),
});

export const dimCustomerContactsFixedInAnalyticsMart = analyticsMart.table("dim_customer_contacts_fixed", {
	contactId: text("contact_id"),
	contactDimKey: text("contact_dim_key"),
	fullName: text("full_name"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	nameTitle: text("name_title"),
	jobTitle: text("job_title"),
	primaryEmail: text("primary_email"),
	secondaryEmail: text("secondary_email"),
	primaryPhone: text("primary_phone"),
	additionalContactMethods: json("additional_contact_methods"),
	primaryContactMethod: text("primary_contact_method"),
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	contactRole: text("contact_role"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	companyContactRank: bigint("company_contact_rank", { mode: "number" }),
	isPrimaryCompanyContact: boolean("is_primary_company_contact"),
	companyHasMultipleContacts: boolean("company_has_multiple_contacts"),
	companyCountry: text("company_country"),
	companyRegion: text("company_region"),
	companyTotalRevenue: doublePrecision("company_total_revenue"),
	companyTotalOrders: numeric("company_total_orders"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	hasMainEmail: boolean("has_main_email"),
	hasCcEmail: boolean("has_cc_email"),
	hasFullName: boolean("has_full_name"),
	hasJobTitle: boolean("has_job_title"),
	hasPhone: boolean("has_phone"),
	isIndividualCustomer: boolean("is_individual_customer"),
	domainType: text("domain_type"),
	customerType: varchar("customer_type"),
	primaryAddress: text("primary_address"),
	city: text(),
	state: text(),
	postalCode: text("postal_code"),
	currentBalance: numeric("current_balance"),
	customerStatus: boolean("customer_status"),
	completenessScore: integer("completeness_score"),
	contactDataQuality: text("contact_data_quality"),
	contactTier: text("contact_tier"),
	engagementPotential: text("engagement_potential"),
	emailMarketable: boolean("email_marketable"),
	phoneContactable: boolean("phone_contactable"),
	keyAccountContact: boolean("key_account_contact"),
	sourceCustomerId: varchar("source_customer_id"),
	sourceCustomerName: text("source_customer_name"),
	sourceCompanyName: text("source_company_name"),
	customerCreatedDate: date("customer_created_date"),
	customerModifiedDate: date("customer_modified_date"),
	isSeed: boolean("is_seed"),
	loadDate: varchar("load_date"),
	contactProcessedAt: timestamp("contact_processed_at", { withTimezone: true, mode: 'string' }),
	dimensionCreatedAt: timestamp("dimension_created_at", { withTimezone: true, mode: 'string' }),
});

export const dimAccountsReceivableAgingInAnalyticsMart = analyticsMart.table("dim_accounts_receivable_aging", {
	analysisLevel: text("analysis_level"),
	orderNumber: varchar("order_number"),
	customer: text(),
	customerSegment: text("customer_segment"),
	orderDate: date("order_date"),
	dueDate: date("due_date"),
	totalAmount: numeric("total_amount"),
	terms: text(),
	daysOutstanding: integer("days_outstanding"),
	daysPastDue: integer("days_past_due"),
	agingBucket: text("aging_bucket"),
	collectionRisk: text("collection_risk"),
	paymentPattern: text("payment_pattern"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	openInvoiceCount: bigint("open_invoice_count", { mode: "number" }),
	totalArAmount: numeric("total_ar_amount"),
	avgDaysOutstanding: numeric("avg_days_outstanding"),
	maxDaysOutstanding: numeric("max_days_outstanding"),
});

export const fctDsoMetricsInAnalyticsMart = analyticsMart.table("fct_dso_metrics", {
	metricCategory: text("metric_category"),
	period: integer(),
	dsoDays: numeric("dso_days"),
	collectionEfficiencyPct: numeric("collection_efficiency_pct"),
	totalAccountsReceivable: numeric("total_accounts_receivable"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	openInvoiceCount: bigint("open_invoice_count", { mode: "number" }),
	dailyAvgSales: numeric("daily_avg_sales"),
	dsoAssessment: text("dso_assessment"),
	customerSegment: text("customer_segment"),
	segmentAr: numeric("segment_ar"),
	avgDaysOutstanding: numeric("avg_days_outstanding"),
});

export const fctCompanyProductsInAnalyticsMart = analyticsMart.table("fct_company_products", {
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	productService: varchar("product_service"),
	productServiceDescription: varchar("product_service_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: text("item_type"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTransactions: bigint("total_transactions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	purchaseDays: bigint("purchase_days", { mode: "number" }),
	totalQuantityPurchased: numeric("total_quantity_purchased"),
	totalAmountSpent: numeric("total_amount_spent"),
	avgUnitPrice: numeric("avg_unit_price"),
	minUnitPrice: numeric("min_unit_price"),
	maxUnitPrice: numeric("max_unit_price"),
	standardSalesPrice: numeric("standard_sales_price"),
	standardPurchaseCost: numeric("standard_purchase_cost"),
	priceVariancePercentage: numeric("price_variance_percentage"),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	firstPurchaseDate: date("first_purchase_date"),
	latestPurchaseDate: date("latest_purchase_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	recentTransactions: bigint("recent_transactions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lastYearTransactions: bigint("last_year_transactions", { mode: "number" }),
	daysSinceLastPurchase: integer("days_since_last_purchase"),
	transactionsPerPurchaseDay: numeric("transactions_per_purchase_day"),
	buyerStatus: text("buyer_status"),
	purchaseVolumeCategory: text("purchase_volume_category"),
	purchaseFrequencyCategory: text("purchase_frequency_category"),
	companyTotalRevenue: doublePrecision("company_total_revenue"),
	productRevenuePercentage: numeric("product_revenue_percentage"),
	primarySalesRep: varchar("primary_sales_rep"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctCompanyOrdersInAnalyticsMart = analyticsMart.table("fct_company_orders", {
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	orderNumber: varchar("order_number"),
	orderType: text("order_type"),
	orderDate: date("order_date"),
	customerName: varchar("customer_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lineItemCount: bigint("line_item_count", { mode: "number" }),
	calculatedOrderTotal: numeric("calculated_order_total"),
	reportedOrderTotal: numeric("reported_order_total"),
	orderTax: numeric("order_tax"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueProducts: bigint("unique_products", { mode: "number" }),
	productFamilies: text("product_families"),
	materialTypes: text("material_types"),
	kitQuantity: numeric("kit_quantity"),
	kitAmount: numeric("kit_amount"),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	salesRep: varchar("sales_rep"),
	paymentMethod: varchar("payment_method"),
	terms: varchar(),
	orderYear: numeric("order_year"),
	orderQuarter: numeric("order_quarter"),
	recencyCategory: text("recency_category"),
	orderSizeCategory: text("order_size_category"),
	productDiversity: text("product_diversity"),
	daysSinceOrder: integer("days_since_order"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const martProductCompanyPeriodSpendingInAnalyticsMart = analyticsMart.table("mart_product_company_period_spending", {
	productService: varchar("product_service"),
	companyDomainKey: text("company_domain_key"),
	periodType: text("period_type"),
	totalAmountSpent: numeric("total_amount_spent"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTransactions: bigint("total_transactions", { mode: "number" }),
	totalQuantityPurchased: numeric("total_quantity_purchased"),
	avgUnitPrice: numeric("avg_unit_price"),
	firstPurchaseDate: date("first_purchase_date"),
	lastPurchaseDate: date("last_purchase_date"),
	latestCustomer: text("latest_customer"),
	latestSourceType: text("latest_source_type"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	companyTotalRevenue: doublePrecision("company_total_revenue"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: text("item_type"),
	standardSalesPrice: numeric("standard_sales_price"),
	standardPurchaseCost: numeric("standard_purchase_cost"),
	standardMarginPercentage: numeric("standard_margin_percentage"),
	lifetimeBuyerStatus: text("lifetime_buyer_status"),
	lifetimeVolumeCategory: text("lifetime_volume_category"),
	lifetimeFrequencyCategory: text("lifetime_frequency_category"),
	lifetimeTotalSpent: numeric("lifetime_total_spent"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lifetimeTotalTransactions: bigint("lifetime_total_transactions", { mode: "number" }),
	periodBuyerStatus: text("period_buyer_status"),
	periodSpendingCategory: text("period_spending_category"),
	priceVariancePercentage: numeric("price_variance_percentage"),
	periodShareOfLifetimeSpending: numeric("period_share_of_lifetime_spending"),
	daysSinceLastPurchase: integer("days_since_last_purchase"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const martCompanyPeriodMetricsInAnalyticsMart = analyticsMart.table("mart_company_period_metrics", {
	companyDomainKey: text("company_domain_key"),
	periodType: text("period_type"),
	totalRevenue: numeric("total_revenue"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalOrders: bigint("total_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	customerCount: bigint("customer_count", { mode: "number" }),
	firstOrderDate: date("first_order_date"),
	latestOrderDate: date("latest_order_date"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	lifetimeTotalRevenue: doublePrecision("lifetime_total_revenue"),
	lifetimeTotalOrders: numeric("lifetime_total_orders"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lifetimeCustomerCount: bigint("lifetime_customer_count", { mode: "number" }),
	lifetimeRevenueCategory: text("lifetime_revenue_category"),
	hasRevenue: boolean("has_revenue"),
	isMultiLocation: boolean("is_multi_location"),
	isCorporate: boolean("is_corporate"),
	periodActivityStatus: text("period_activity_status"),
	periodRevenueCategory: text("period_revenue_category"),
	periodShareOfLifetimeRevenue: numeric("period_share_of_lifetime_revenue"),
	daysSinceLatestOrder: integer("days_since_latest_order"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctCompanyOrdersTimeSeriesInAnalyticsMart = analyticsMart.table("fct_company_orders_time_series", {
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	orderYear: numeric("order_year"),
	orderQuarter: numeric("order_quarter"),
	periodKey: text("period_key"),
	periodStartDate: date("period_start_date"),
	periodEndDate: date("period_end_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	orderCount: bigint("order_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueCustomers: bigint("unique_customers", { mode: "number" }),
	totalRevenue: numeric("total_revenue"),
	avgOrderValue: numeric("avg_order_value"),
	totalUniqueProducts: numeric("total_unique_products"),
	avgProductsPerOrder: numeric("avg_products_per_order"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	largeOrders: bigint("large_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	mediumOrders: bigint("medium_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	smallOrders: bigint("small_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	microOrders: bigint("micro_orders", { mode: "number" }),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	qoqOrderGrowthPct: numeric("qoq_order_growth_pct"),
	qoqRevenueGrowthPct: numeric("qoq_revenue_growth_pct"),
	yoyOrderGrowthPct: numeric("yoy_order_growth_pct"),
	yoyRevenueGrowthPct: numeric("yoy_revenue_growth_pct"),
	yoyGrowthTrend: text("yoy_growth_trend"),
	yoyRevenueTrend: text("yoy_revenue_trend"),
	quarterlyRevenueTier: text("quarterly_revenue_tier"),
	quarterlyActivityLevel: text("quarterly_activity_level"),
	quarterLabel: text("quarter_label"),
	isCurrentQuarter: boolean("is_current_quarter"),
	exceptionalGrowthFlag: boolean("exceptional_growth_flag"),
	concerningDeclineFlag: boolean("concerning_decline_flag"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctInventoryHistoryInAnalyticsMart = analyticsMart.table("fct_inventory_history", {
	itemName: varchar("item_name"),
	inventoryDate: date("inventory_date"),
	quantityOnHand: numeric("quantity_on_hand"),
	quantityOnOrder: numeric("quantity_on_order"),
	quantityOnSalesOrder: numeric("quantity_on_sales_order"),
	availableQuantity: numeric("available_quantity"),
	totalInventoryVisibility: numeric("total_inventory_visibility"),
	previousQuantityOnHand: numeric("previous_quantity_on_hand"),
	quantityChange: numeric("quantity_change"),
	productDescription: varchar("product_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	unitOfMeasure: varchar("unit_of_measure"),
	salesPrice: numeric("sales_price"),
	purchaseCost: numeric("purchase_cost"),
	inventoryValueAtCost: numeric("inventory_value_at_cost"),
	inventoryValueAtSalesPrice: numeric("inventory_value_at_sales_price"),
	itemStatus: boolean("item_status"),
	isSeed: boolean("is_seed"),
	originalSnapshotDate: varchar("original_snapshot_date"),
});

export const dimCompanyHealthInAnalyticsMart = analyticsMart.table("dim_company_health", {
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: text("domain_type"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	healthScore: numeric("health_score"),
	customerArchetype: text("customer_archetype"),
	activityStatus: text("activity_status"),
	engagementLevel: text("engagement_level"),
	growthTrendDirection: text("growth_trend_direction"),
	combinedGrowthTrend: text("combined_growth_trend"),
	orderFrequencyCategory: text("order_frequency_category"),
	daysSinceLastOrder: integer("days_since_last_order"),
	lastOrderDate: date("last_order_date"),
	firstOrderDate: date("first_order_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalOrders: bigint("total_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeYears: bigint("active_years", { mode: "number" }),
	ordersPerYear: numeric("orders_per_year"),
	totalRevenue: numeric("total_revenue"),
	avgOrderValue: numeric("avg_order_value"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersLast90Days: bigint("orders_last_90_days", { mode: "number" }),
	revenueLast90Days: numeric("revenue_last_90_days"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersLastYear: bigint("orders_last_year", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersPriorYear: bigint("orders_prior_year", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	productDiversityScore: bigint("product_diversity_score", { mode: "number" }),
	revenuePercentile: doublePrecision("revenue_percentile"),
	healthCategory: text("health_category"),
	atRiskFlag: boolean("at_risk_flag"),
	growthOpportunityFlag: boolean("growth_opportunity_flag"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctCompaniesInAnalyticsMart = analyticsMart.table("fct_companies", {
	companyDomainKey: text("company_domain_key"),
	domainType: text("domain_type"),
	companyName: varchar("company_name"),
	primaryEmail: varchar("primary_email"),
	primaryPhone: varchar("primary_phone"),
	primaryBillingAddressLine1: varchar("primary_billing_address_line_1"),
	primaryBillingCity: varchar("primary_billing_city"),
	primaryBillingState: varchar("primary_billing_state"),
	primaryBillingPostalCode: varchar("primary_billing_postal_code"),
	primaryCountry: text("primary_country"),
	region: text(),
	countryCategory: text("country_category"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	customerCount: bigint("customer_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueCustomerNames: bigint("unique_customer_names", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueCompanyNames: bigint("unique_company_names", { mode: "number" }),
	totalCurrentBalance: numeric("total_current_balance"),
	totalRevenue: doublePrecision("total_revenue"),
	totalOrders: numeric("total_orders"),
	totalLineItems: numeric("total_line_items"),
	firstOrderDate: date("first_order_date"),
	latestOrderDate: date("latest_order_date"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	customerNamesSample: text("customer_names_sample"),
	hasRevenue: boolean("has_revenue"),
	isMultiLocation: boolean("is_multi_location"),
	isCorporate: boolean("is_corporate"),
	enrichedIndustry: varchar("enriched_industry"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	enrichedEmployeeCount: bigint("enriched_employee_count", { mode: "number" }),
	enrichedDescription: varchar("enriched_description"),
	enrichedFoundedYear: integer("enriched_founded_year"),
	enrichedAnnualRevenue: varchar("enriched_annual_revenue"),
	enrichmentSource: varchar("enrichment_source"),
	enrichmentDate: timestamp("enrichment_date", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const dimCustomerContactsInAnalyticsMart = analyticsMart.table("dim_customer_contacts", {
	contactDimKey: text("contact_dim_key"),
	contactId: text("contact_id"),
	fullName: text("full_name"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	nameTitle: text("name_title"),
	jobTitle: text("job_title"),
	primaryEmail: text("primary_email"),
	secondaryEmail: text("secondary_email"),
	primaryPhone: text("primary_phone"),
	additionalContactMethods: json("additional_contact_methods"),
	primaryContactMethod: text("primary_contact_method"),
	companyDomainKey: text("company_domain_key"),
	companyName: varchar("company_name"),
	contactRole: text("contact_role"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	companyContactRank: bigint("company_contact_rank", { mode: "number" }),
	isPrimaryCompanyContact: boolean("is_primary_company_contact"),
	companyHasMultipleContacts: boolean("company_has_multiple_contacts"),
	companyCountry: text("company_country"),
	companyRegion: text("company_region"),
	companyTotalRevenue: doublePrecision("company_total_revenue"),
	companyTotalOrders: numeric("company_total_orders"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	hasMainEmail: boolean("has_main_email"),
	hasCcEmail: boolean("has_cc_email"),
	hasFullName: boolean("has_full_name"),
	hasJobTitle: boolean("has_job_title"),
	hasPhone: boolean("has_phone"),
	isIndividualCustomer: boolean("is_individual_customer"),
	domainType: text("domain_type"),
	customerType: varchar("customer_type"),
	primaryAddress: varchar("primary_address"),
	city: varchar(),
	state: varchar(),
	postalCode: varchar("postal_code"),
	currentBalance: numeric("current_balance", { precision: 38, scale:  9 }),
	customerStatus: boolean("customer_status"),
	contactDataQuality: text("contact_data_quality"),
	contactTier: text("contact_tier"),
	emailMarketable: boolean("email_marketable"),
	phoneContactable: boolean("phone_contactable"),
	keyAccountContact: boolean("key_account_contact"),
	sourceCustomerId: varchar("source_customer_id"),
	sourceCustomerName: varchar("source_customer_name"),
	sourceCompanyName: varchar("source_company_name"),
	customerCreatedDate: varchar("customer_created_date"),
	customerModifiedDate: varchar("customer_modified_date"),
	isSeed: boolean("is_seed"),
	loadDate: varchar("load_date"),
	contactProcessedAt: timestamp("contact_processed_at", { withTimezone: true, mode: 'string' }),
	dimensionCreatedAt: timestamp("dimension_created_at", { withTimezone: true, mode: 'string' }),
});

export const fctProductPricingHistoryInAnalyticsMart = analyticsMart.table("fct_product_pricing_history", {
	productService: varchar("product_service"),
	orderDate: date("order_date"),
	avgUnitPrice: numeric("avg_unit_price"),
	totalUnitsSold: numeric("total_units_sold"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	transactionCount: bigint("transaction_count", { mode: "number" }),
	isActualProduct: boolean("is_actual_product"),
	priceCluster: numeric("price_cluster"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	clusterFrequency30D: bigint("cluster_frequency_30d", { mode: "number" }),
	clusterVolume30D: numeric("cluster_volume_30d"),
	volumeCategory: text("volume_category"),
	stableRetailCandidate: numeric("stable_retail_candidate"),
	dominantPriceCandidate: numeric("dominant_price_candidate"),
	inferredRetailPrice: numeric("inferred_retail_price"),
	authoritativePrice: numeric("authoritative_price"),
	priceEffectiveDate: date("price_effective_date"),
	retailPriceAtDate: numeric("retail_price_at_date"),
	retailPriceSource: text("retail_price_source"),
	prevAvgPrice: numeric("prev_avg_price"),
	prevSaleDate: date("prev_sale_date"),
	prevRetailPrice: numeric("prev_retail_price"),
	priceTrend: text("price_trend"),
	priceChangeAmount: numeric("price_change_amount"),
	priceChangePercentage: numeric("price_change_percentage"),
	daysSinceLastSale: integer("days_since_last_sale"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	currentListPrice: numeric("current_list_price"),
	currentPurchaseCost: numeric("current_purchase_cost"),
	discountFromRetailPct: numeric("discount_from_retail_pct"),
	discountFromRetailAmount: numeric("discount_from_retail_amount"),
	retailPriceChangeType: text("retail_price_change_type"),
	retailPriceChangeAmount: numeric("retail_price_change_amount"),
	retailPriceChangePct: numeric("retail_price_change_pct"),
	discountFromCurrentListPct: numeric("discount_from_current_list_pct"),
	discountFromCurrentListAmount: numeric("discount_from_current_list_amount"),
});

export const fctOrderLineItemsInAnalyticsMart = analyticsMart.table("fct_order_line_items", {
	lineItemId: varchar("line_item_id"),
	orderNumber: varchar("order_number"),
	sourceType: text("source_type"),
	orderDate: date("order_date"),
	customer: varchar(),
	paymentMethod: varchar("payment_method"),
	status: text(),
	dueDate: date("due_date"),
	productService: varchar("product_service"),
	productServiceDescription: varchar("product_service_description"),
	productServiceQuantity: numeric("product_service_quantity"),
	productServiceRate: numeric("product_service_rate"),
	productServiceAmount: numeric("product_service_amount"),
	productServiceClass: varchar("product_service_class"),
	unitOfMeasure: varchar("unit_of_measure"),
	customerSalesTaxCode: varchar("customer_sales_tax_code"),
	isTaxExempt: boolean("is_tax_exempt"),
	productServiceSalesTaxCode: varchar("product_service_sales_tax_code"),
	billingAddress: text("billing_address"),
	billingAddressCity: varchar("billing_address_city"),
	billingAddressState: varchar("billing_address_state"),
	billingAddressPostalCode: varchar("billing_address_postal_code"),
	billingAddressCountry: text("billing_address_country"),
	shippingAddress: text("shipping_address"),
	shippingAddressCity: varchar("shipping_address_city"),
	shippingAddressState: varchar("shipping_address_state"),
	shippingAddressPostalCode: varchar("shipping_address_postal_code"),
	shippingAddressCountry: text("shipping_address_country"),
	primaryCountry: text("primary_country"),
	countryCategory: text("country_category"),
	region: text(),
	shippingMethod: varchar("shipping_method"),
	shipDate: date("ship_date"),
	memo: varchar(),
	messageToCustomer: varchar("message_to_customer"),
	terms: varchar(),
	salesRep: varchar("sales_rep"),
	class: varchar(),
	productServiceServiceDate: varchar("product_service_service_date"),
	inventorySite: varchar("inventory_site"),
	inventoryBin: varchar("inventory_bin"),
	serialNo: varchar("serial_no"),
	lotNo: varchar("lot_no"),
	externalId: varchar("external_id"),
	quickbooksInternalId: varchar("quickbooks_internal_id"),
	currency: varchar(),
	exchangeRate: varchar("exchange_rate"),
	createdDate: timestamp("created_date", { mode: 'string' }),
	modifiedDate: timestamp("modified_date", { mode: 'string' }),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	productSalesDescription: varchar("product_sales_description"),
	standardSalesPrice: numeric("standard_sales_price"),
	standardPurchaseCost: numeric("standard_purchase_cost"),
	marginPercentage: numeric("margin_percentage"),
	marginAmount: numeric("margin_amount"),
	primaryContactId: text("primary_contact_id"),
	primaryContactName: text("primary_contact_name"),
	primaryContactEmail: text("primary_contact_email"),
	primaryContactPhone: text("primary_contact_phone"),
	primaryContactRole: text("primary_contact_role"),
});
